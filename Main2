import random
from sympy.ntheory.modular import crt

# Elliptic curve parameters (secp256k1)
P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
A, B = 0, 7
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
G = (Gx, Gy)
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

# Small moduli (32-bit primes)
small_moduli = [
    4294967291, 4294967279, 4294967231, 4294967197, 4294967189, 4294967187,
    4294967171, 4294967161, 4294967143, 4294967129, 4294967111, 4294967107,
    4294967099, 4294967087, 4294967073, 4294967057, 4294967043, 4294967039,
    4294967029, 4294967011, 4294967007, 4294966997, 4294966981, 4294966979,
    4294966973, 4294966967, 4294966953, 4294966949, 4294966943, 4294966933,
    4294966927, 4294966919, 4294966911, 4294966903, 4294966891, 4294966889,
    4294966883, 4294966877, 4294966869, 4294966861, 4294966853, 4294966849,
    4294966841, 4294966833, 4294966823, 4294966811, 4294966803, 4294966799
]

# Elliptic curve point addition modulo p
def point_add(p_mod, P, Q):
    if P is None:
        return Q
    if Q is None:
        return P
    x1, y1 = P
    x2, y2 = Q
    if x1 == x2 and (y1 + y2) % p_mod == 0:
        return None
    if x1 == x2 and y1 == y2:
        l = (3 * x1 * x1) * pow(2 * y1, -1, p_mod) % p_mod
    else:
        l = (y2 - y1) * pow(x2 - x1, -1, p_mod) % p_mod
    x3 = (l * l - x1 - x2) % p_mod
    y3 = (l * (x1 - x3) - y1) % p_mod
    return (x3, y3)

# Scalar multiplication modulo p
def scalar_mult(p_mod, k, P):
    result = None
    addend = P
    while k > 0:
        if k & 1:
            result = point_add(p_mod, result, addend)
        addend = point_add(p_mod, addend, addend)
        k >>= 1
    return result

# Fold a point modulo p_mod
def fold_point(P, p_mod):
    if P is None:
        return None
    x, y = P
    return (x % p_mod, y % p_mod)

# Extended Euclidean algorithm for modular inverse
def modinv(a, m):
    g, x, _ = extended_gcd(a, m)
    if g != 1:
        return None  # No inverse
    return x % m

def extended_gcd(a, b):
    if b == 0:
        return (a, 1, 0)
    else:
        g, y, x = extended_gcd(b, a % b)
        return (g, x, y - (a // b) * x)

# Pollard's Rho for ECDLP modulo p
def pollards_rho_ecdlog(p, G, Q):
    # Order estimate: p
    def f(X, A, B):
        x, y = X
        if x % 3 == 0:
            # Set 1
            Xn = point_add(p, X, G)
            An = (A + 1) % p
            Bn = B
        elif x % 3 == 1:
            # Set 2
            Xn = point_add(p, X, X)
            An = (2 * A) % p
            Bn = (2 * B) % p
        else:
            # Set 3
            Xn = point_add(p, X, Q)
            An = A
            Bn = (B + 1) % p
        return Xn, An, Bn

    # Initialize
    x, a, b = G, 1, 0
    X, A, B = G, 1, 0

    for i in range(p * 2):
        x, a, b = f(x, a, b)
        X, A, B = f(*f(X, A, B))  # Move twice

        if x == X:
            r = (a - A) % p
            s = (B - b) % p
            if r == 0:
                return None  # Failure, retry needed
            inv_r = modinv(r, p)
            if inv_r is None:
                return None
            d = (s * inv_r) % p
            # Verify result
            if scalar_mult(p, d, G) == Q:
                return d
            else:
                return None
    return None

def pfich_recover_d(Qx, Qy):
    Q = (Qx, Qy)
    residues = []
    moduli_used = []
    total_bits = 0

    for mod in small_moduli:
        G_folded = fold_point(G, mod)
        Q_folded = fold_point(Q, mod)
        if G_folded is None or Q_folded is None:
            continue
        d_mod = pollards_rho_ecdlog(mod, G_folded, Q_folded)
        if d_mod is not None:
            residues.append(d_mod)
            moduli_used.append(mod)
            total_bits += mod.bit_length()
            print(f"[+] Solved mod {mod} (bit sum: {total_bits})")
            if total_bits >= 260:
                break

    if len(residues) < 2:
        return None

    d_recovered, _ = crt(moduli_used, residues)
    return d_recovered % N

# Example main usage:
if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print("Usage: python3 crack_full_key.py <pubkey_x> <pubkey_y>")
        sys.exit(1)

    pubkey_x = int(sys.argv[1])
    pubkey_y = int(sys.argv[2])

    d = pfich_recover_d(pubkey_x, pubkey_y)
    if d:
        print("[+] ✅ FULL Private Key Recovered:")
        print(hex(d))
    else:
        print("[-] ❌ Could not recover key. Try more moduli or retry.")