# Toy elliptic curve setup (for clarity)
# We'll simulate EC math manually

# Curve order (n)
n = 97  # small prime for demo
Gx = 5  # fake generator x
Gy = 1  # fake generator y
G = (Gx, Gy)

# Simulated scalar multiply (fake, just for structure)
def point_mul(k, P):
    return ((P[0] * k) % n, (P[1] * k) % n)

# Simulated add (fake structure)
def point_add(P1, P2):
    return ((P1[0] + P2[0]) % n, (P1[1] + P2[1]) % n)

# Modular inverse
def modinv(a, n):
    return pow(a, -1, n)

# Our "private key"
d = 45

# Q = d·G
Q = point_mul(d, G)

# Let's pick a = 3, b = 2
a = 3
b = 2

# Compute R = a·G + b·Q
aG = point_mul(a, G)
bQ = point_mul(b, Q)
R = point_add(aG, bQ)

r = R[0] % n

# Compute s and z
s = (r * modinv(b, n)) % n
z = (r * a * modinv(b, n)) % n

# Slightly modify z to simulate fake sig
z += 1
z = z % n

# Show values
print(f"G: {G}")
print(f"Q (public key): {Q}")
print(f"R: {R}")
print(f"r: {r}")
print(f"s: {s}")
print(f"z (modified): {z}")

# Now solve for d
numerator = (z - s * a) % n
denominator = (s * b - r) % n
d_recovered = (numerator * modinv(denominator, n)) % n

print(f"Recovered d: {d_recovered}")
print(f"Original d:  {d}")