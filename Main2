from sympy.ntheory.modular import crt
import sys
from math import isqrt

# secp256k1 constants
P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
A, B = 0, 7
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
G = (Gx, Gy)
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

# List of distinct 32-bit safe primes manually selected
small_moduli = [
    4294967291, 4294967279, 4294967231, 4294967197, 4294967189, 4294967187,
    4294967171, 4294967161, 4294967143, 4294967129, 4294967111, 4294967107,
    4294967099, 4294967087, 4294967073, 4294967057, 4294967043, 4294967039,
    4294967029, 4294967011, 4294967007, 4294966997, 4294966981, 4294966979,
    4294966973, 4294966967, 4294966953, 4294966949, 4294966943, 4294966933,
    4294966927, 4294966919, 4294966911, 4294966903, 4294966891, 4294966889,
    4294966883, 4294966877, 4294966869, 4294966861, 4294966853, 4294966849,
    4294966841, 4294966833, 4294966823, 4294966811, 4294966803, 4294966799
]

def is_on_curve(x, y, p):
    return (y * y - (x * x * x + A * x + B)) % p == 0

def point_add(p_mod, P, Q):
    if P is None:
        return Q
    if Q is None:
        return P
    x1, y1 = P
    x2, y2 = Q
    if x1 == x2 and y1 != y2:
        return None
    if x1 == x2:
        l = (3 * x1 * x1) * pow(2 * y1, -1, p_mod)
    else:
        l = (y2 - y1) * pow(x2 - x1, -1, p_mod)
    l %= p_mod
    x3 = (l * l - x1 - x2) % p_mod
    y3 = (l * (x1 - x3) - y1) % p_mod
    return (x3, y3)

def scalar_mult(p_mod, k, P):
    result = None
    addend = P
    while k:
        if k & 1:
            result = point_add(p_mod, result, addend)
        addend = point_add(p_mod, addend, addend)
        k >>= 1
    return result

def fold_point(P, p):
    x, y = P
    x_mod = x % p
    y_mod = y % p
    if is_on_curve(x_mod, y_mod, p):
        return (x_mod, y_mod)
    else:
        return None  # Invalid point on this modulus

def baby_step_giant_step(mod, G, Q):
    m = isqrt(mod) + 1
    table = {}
    R = None
    # Baby steps
    for j in range(m):
        table[R] = j
        R = point_add(mod, R, G) if R else G
    # Compute inverse of m*G
    mG = scalar_mult(mod, m, G)
    inv_mG = scalar_mult(mod, pow(m, -1, mod), mG)
    inv_mG = scalar_mult(mod, mod - 1, inv_mG)  # Inverse of mG
    curr = Q
    # Giant steps
    for i in range(m):
        if curr in table:
            return i * m + table[curr]
        curr = point_add(mod, curr, inv_mG)
    return None

def pfich_recover_d(Qx, Qy):
    Q = (Qx, Qy)
    residues = []
    moduli_used = []
    total_bits = 0

    for mod in small_moduli:
        G_folded = fold_point(G, mod)
        Q_folded = fold_point(Q, mod)
        if G_folded is None or Q_folded is None:
            continue  # skip invalid moduli
        d_mod = baby_step_giant_step(mod, G_folded, Q_folded)
        if d_mod is not None:
            residues.append(d_mod)
            moduli_used.append(mod)
            total_bits += mod.bit_length()
            print(f"[+] Solved mod {mod} (bit sum: {total_bits})")
        if total_bits >= 260:
            break

    if len(residues) < 2:
        return None

    d_recovered, _ = crt(moduli_used, residues)
    return d_recovered % N

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python3 crack_full_key.py <pubkey_x> <pubkey_y>")
        sys.exit(1)

    pubkey_x = int(sys.argv[1])
    pubkey_y = int(sys.argv[2])

    d = pfich_recover_d(pubkey_x, pubkey_y)

    if d:
        print("[+] ✅ FULL Private Key Recovered:")
        print(hex(d))
    else:
        print("[-] ❌ Could not recover key. Check input or try more moduli.")