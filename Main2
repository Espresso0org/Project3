from sympy.ntheory.modular import crt
import sys
from multiprocessing import Pool, cpu_count

# secp256k1 constants
P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
A, B = 0, 7
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
G = (Gx, Gy)
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

small_moduli = [
    4294967291, 4294967279, 4294967231, 4294967197, 4294967189, 4294967187,
    4294967171, 4294967161, 4294967143, 4294967129, 4294967111, 4294967107,
    4294967099, 4294967087, 4294967073, 4294967057, 4294967043, 4294967039,
    4294967029, 4294967011, 4294967007, 4294966997, 4294966981, 4294966979,
    4294966973, 4294966967, 4294966953, 4294966949, 4294966943, 4294966933,
    4294966927, 4294966919, 4294966911, 4294966903, 4294966891, 4294966889,
    4294966883, 4294966877, 4294966869, 4294966861, 4294966853, 4294966849,
    4294966841, 4294966833, 4294966823, 4294966811, 4294966803, 4294966799
]

def point_add(p_mod, P, Q):
    if P is None: return Q
    if Q is None: return P
    x1, y1 = P
    x2, y2 = Q
    if x1 == x2 and y1 != y2: return None
    if x1 == x2:
        l = (3 * x1 * x1) * pow(2 * y1, -1, p_mod)
    else:
        l = (y2 - y1) * pow(x2 - x1, -1, p_mod)
    l %= p_mod
    x3 = (l * l - x1 - x2) % p_mod
    y3 = (l * (x1 - x3) - y1) % p_mod
    return (x3, y3)

def scalar_mult(p_mod, k, P):
    result = None
    addend = P
    while k:
        if k & 1:
            result = point_add(p_mod, result, addend)
        addend = point_add(p_mod, addend, addend)
        k >>= 1
    return result

def fold_point(P, modulus):
    x, y = P
    return (x % modulus, y % modulus)

def is_on_curve(p_mod, P):
    if P is None:
        return False
    x, y = P
    return (y * y - (x * x * x + A * x + B)) % p_mod == 0

def get_point_order(p_mod, P):
    # Try small multiples of P to find order (up to a limit)
    # Return None if not found within limit
    limit = 10000
    R = P
    for i in range(1, limit+1):
        if R is None:
            return i
        R = point_add(p_mod, R, P)
    return None

def pollards_rho_discrete_log(p_mod, G_folded, Q_folded, order=None):
    import random

    if order is None:
        order = p_mod

    def f(X, a, b):
        x, a_, b_ = X
        if x[0] % 3 == 0:
            x = point_add(p_mod, x, G_folded)
            a_ = (a_ + 1) % order
        elif x[0] % 3 == 1:
            x = point_add(p_mod, x, Q_folded)
            b_ = (b_ + 1) % order
        else:
            x = point_add(p_mod, x, x)
            a_ = (2 * a_) % order
            b_ = (2 * b_) % order
        return (x, a_, b_)

    x = G_folded
    a = 1
    b = 0
    X = (x, a, b)
    x_prime = X

    for i in range(1, order):
        X = f(*X)
        x_prime = f(*f(*x_prime))

        if X[0] == x_prime[0]:
            r = (X[1] - x_prime[1]) % order
            s = (x_prime[2] - X[2]) % order
            if s == 0:
                return None
            inv_s = pow(s, -1, order)
            return (r * inv_s) % order
    return None

def pfich_recover_d(Qx, Qy):
    Q = (Qx, Qy)
    residues = []
    moduli_used = []
    total_bits = 0

    with Pool(cpu_count()) as pool:
        tasks = []
        for mod in small_moduli:
            G_folded = fold_point(G, mod)
            Q_folded = fold_point(Q, mod)
            tasks.append((mod, G_folded, Q_folded))

        results = pool.map(entropy_probe_parallel, tasks)

    for mod, d_mod in results:
        if d_mod is not None:
            residues.append(d_mod)
            moduli_used.append(mod)
            total_bits += mod.bit_length()
            print(f"[+] Solved mod {mod} (bit sum: {total_bits})")
            if total_bits >= 260:
                break

    if len(residues) < 2:
        return None

    d_recovered, _ = crt(moduli_used, residues)
    return d_recovered % N

def entropy_probe_parallel(args):
    mod, G_folded, Q_folded = args
    d_mod = pollards_rho_discrete_log(mod, G_folded, Q_folded)
    return (mod, d_mod)

def test_moduli_diagnostics(d_input):
    print(f"\n[*] Diagnostic Test for d = {d_input}\n")

    Qx, Qy = scalar_mult(P, d_input, G)
    Q = (Qx, Qy)

    success = 0
    total_bits = 0

    for mod in small_moduli:
        G_folded = fold_point(G, mod)
        Q_folded = fold_point(Q, mod)

        if not is_on_curve(mod, G_folded):
            print(f"[x] mod {mod} ❌ G_folded not on curve")
            continue
        if not is_on_curve(mod, Q_folded):
            print(f"[x] mod {mod} ❌ Q_folded not on curve")
            continue

        order = get_point_order(mod, G_folded)
        if order is None or order < 10:
            print(f"[x] mod {mod} ❌ Invalid point order: {order}")
            continue

        d_mod = pollards_rho_discrete_log(mod, G_folded, Q_folded, order)
        if d_mod == (d_input % order):
            print(f"[✓] mod {mod} ✅ SUCCESS — Found correct d mod {mod}")
            total_bits += mod.bit_length()
            success += 1
        elif d_mod is not None:
            print(f"[~] mod {mod} ⚠️ WRONG result — Got d ≡ {d_mod} mod {mod}, expected {d_input % order}")
        else:
            print(f"[ ] mod {mod} ❓ Pollard's rho failed")

    print(f"\n[!] Total successful moduli: {success}")
    print(f"[!] Total bits of information collected: {total_bits}\n")

if __name__ == "__main__":
    # Example usage:
    # python3 this_script.py <pubkey_x> <pubkey_y> or
    # Run diagnostics on chosen d:
    test_moduli_diagnostics(1)
    test_moduli_diagnostics(2)
    test_moduli_diagnostics(3)
    test_moduli_diagnostics(17)