from ecdsa import SECP256k1, ellipticcurve, numbertheory
from ecdsa.ecdsa import generator_secp256k1
import random

curve = SECP256k1
G = generator_secp256k1
n = G.order()

def modinv(a, n):
    return numbertheory.inverse_mod(a, n)

def compute_R(a, b, Q):
    return a * G + b * Q

def forge_signature(a, b, Q_point, fudge_z=0, fudge_s=0):
    R = compute_R(a, b, Q_point)
    r = R.x() % n
    if b == 0:
        raise ValueError("b must not be 0")
    s = (r * modinv(b, n)) % n
    z = (r * a * modinv(b, n)) % n

    s = (s + fudge_s) % n
    z = (z + fudge_z) % n

    return {'r': r, 's': s, 'z': z, 'a': a, 'b': b}

def extract_d(sig):
    r, s, z, a, b = sig['r'], sig['s'], sig['z'], sig['a'], sig['b']
    numerator = (z - s * a) % n
    denominator = (s * b - r) % n
    if denominator == 0:
        raise ZeroDivisionError("Invalid signature: denominator is 0")
    d = (numerator * modinv(denominator, n)) % n
    return d

if __name__ == "__main__":
    # Random private key
    d = random.randint(1, n-1)
    print(f"Random private key d (secret): {d}")

    Q_point = d * G

    sig1 = forge_signature(a=2, b=1, Q_point=Q_point)
    sig2 = forge_signature(a=3, b=2, Q_point=Q_point, fudge_z=7)  # slight fudge

    print(f"Signature 1: {sig1}")
    print(f"Signature 2: {sig2}")

    recovered_d = extract_d(sig2)
    print(f"Recovered private key d: {recovered_d}")

    print(f"Success? {'YES' if recovered_d == d else 'NO'}")